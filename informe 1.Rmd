---
title: "Análisis de procesos puntuales para actividad comercial en Medellín"
author: "Julian Castaño Pineda - Luisa Henao Vargas"
date: "2024-09-25"
output: 
  html_document: 
    theme: united
    highlight: tango
    toc: yes
    toc_float: yes
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(sf)
library(mapview)
library(spatstat)
```

# Pregunta de Investigación 

¿Cuál es la distribución espacial de la apertura de une establecimiento comercial de bebidas alcohólicas y tabaco en la ciudad de Medellín, y cómo puede esta información guiar la ubicación estratégica de nuevos establecimientos en función de la demanda potencial?

El objetivo de este estudio es analizar la distribución de licoreras y cigarrerías georreferenciadas, explorando e identificando posibles patrones y áreas de alta concentración, para proporcionar recomendaciones sobre la ubicación estratégica de nuevos negocios en función de la competencia, la demanda del mercado y las características sociodemográficas de la zona.

Esto permite no solo entender la distribución actual, sino también ofrecer información valiosa para la toma de decisiones empresariales.

# Datos

Los datos fueron obtenidos de: <https://www.medellin.gov.co/geomedellin/datosAbiertos/1024>

**Establecimientos de Industria y Comercio** de los contribuyentes inscritos en el Registro de información tributaria (RIT) georreferenciados, con el tipo de actividad económica desarrollada por el contribuyente. Se actualiza en línea con la inscripción, cancelación o actualización de los establecimientos en el sistema de información de la subsecretaría.

```{r, message=FALSE, include=FALSE}
# Cargar el archivo geojson de datos de comercios en medellín
pp_data <- st_read("establecimientos_de_indus.geojson")
# Cargar el archivo geojson de barrios y veredas de medellín
medellin <- st_read("barrios_y_veredas.geojson")
```

```{r, eval=FALSE}
# Ver estructura de los datos
class(pp_data)
class(medellin)
str(pp_data)
str(medellin)
```


```{r}
pp_data <- pp_data %>% filter(nombre_establecimiento != "NO POSEE ESTABLECIMIENTOS") 
```

# Visualización datos{.tabset}

## Mapa por ciuu barrios y comunas 
```{r, warning=FALSE}
codigos = pp_data$codigociiu %>% unique() %>% sort()
codigo_ciiu = 4741
codigo_ciiu = codigos[344]
comercios_min <- pp_data %>% filter(codigociiu == codigo_ciiu)
# Graficar Medellín coloreando los barrios y superponiendo los puntos de los establecimientos
ggplot() +
  geom_sf(data = medellin, color = "black", alpha = 0.3) +  # Colorear los barrios
  geom_sf(data = comercios_min, aes(color = codigociiu), alpha = 0.7) +  # Superponer los puntos
  labs(title = "Establecimientos Comerciales por código CIUU en Medellín", fill = "Barrios", color = "Código CIUU") +
  theme_minimal()
```

## Mapa solo barrios

```{r, warning=FALSE}
codigos = pp_data$codigociiu %>% unique() %>% sort()
codigo_ciiu = 4741
codigo_ciiu = codigos[344]
comercios_min <- pp_data %>% filter(codigociiu == codigo_ciiu)

medellin_b <- medellin %>% filter(subtipo_barriovereda == 1)


points_intersect <- lengths(st_intersects(comercios_min, medellin_b)) > 0 
comercios_min_b <- comercios_min[points_intersect, ]

# Graficar Medellín coloreando los barrios y superponiendo los puntos de los establecimientos
ggplot() +
  geom_sf(data = medellin_b, color = "black", alpha = 0.3) +  # Colorear los barrios
  geom_sf(data= comercios_min_b, aes(color = codigociiu), alpha = 0.7) +  # Superponer los puntos
  labs(title = "Establecimientos Comerciales por código CIUU en Medellín", color = "Código CIUU") +
  theme_minimal()
```

## Mapa interactivo (mapview)

```{r}
rm(pp_data,comercios_min,medellin)
mapview(comercios_min_b,
  zcol = "comuna",
  label = comercios_min_b$nombre_establecimiento,
  legend = TRUE
)

```

## Datos 

```{r}
comercios_min_b %>% str()
```

# Pruebas de cuadratura{.tabset}
quadratcount: Divide el área de Medellín en una cuadrícula de 3x4 para contar el número de puntos en cada cuadrante.
quadrat.test: Realiza una prueba de Chi-cuadrado para evaluar si la distribución espacial es aleatoria o no.

Si los datos rechazan la hipótesis de aleatoriedad espacial se puede decir que los datos tienen una estructura espacial bien sea de cluster o inhibitoria.

## Creación de objeto ppp

```{r, warning=FALSE}
win <- as.owin(medellin_b)

ppp_locations <- ppp(
  x = st_coordinates(comercios_min_b)[, 1],
  y = st_coordinates(comercios_min_b)[, 2],
  window = win
)

unitname(ppp_locations) <- "meters"

ppp_locations <- as.ppp(ppp_locations)

koords = c(2241000, 2257000)
ppp_locations$window$yrange = koords

plot(ppp_locations)
```

## Plot

```{r}
par(mar = c(0, 0, 1.5, 1.5),
    cex.main = 2)

qc_locations <- quadratcount(ppp_locations, nx = 3, ny = 4)
plot(ppp_locations, pch = 3, cex = 0.6)
plot(qc_locations, add = TRUE, textargs = list(col = "red"))
```

## Test

```{r, warning=FALSE}
quadrat.test(qc_locations)
```

# Estimación de la intensidad del proceso

## Estimación por suavizado Kernel:

$$\hat{\lambda}(x) = \frac{1}{h^2} \sum_{i=1}^{n} \frac{\kappa\left(\frac{\|x - x_i\|}{h}\right)}{q\left(\|x\|\right)}$$

Se calcularon 2 tipos de kernel. Kernel gaussiano y un kernel quartic.

**1. Kernel cuártico (o biweight kernel):**

$$K(u) = \frac{15}{16}(1 - u^2)^2 \quad \text{para} \quad |u| \leq 1$$

$$K(u) = 0 \quad \text{para} \quad |u| > 1$$

**2. Kernel gaussiano:**

$$K(u) = \frac{1}{\sqrt{2\pi}} \exp\left(-\frac{u^2}{2}\right)$$


Se utilizaron 3 valores diferentes para el ancho de banda del kernel (1000, 2500, 5000), que representan el parámetro de suavizado de la función de densidad. Este parametro controla el grado de suavidad en la estimación de la intensidad. Valores más pequeños generan estimaciones más detalladas, mientras que valores más grandes suavizan más la intensidad. 
Para todos los casos se observa que 1000 puede ser un ancho de banda aduecuado, no se observan mucha diferencia entre los kernel quartic y gaussiano.


```{r}
par(mfrow = c(2, 3), mar = c(0, 0, 1, 2))
sigma <- c(500, 1000, 1500)
main <- c("Gaussiano","Quartic")
kernels <- c("gaussian","quartic")
for (i in 1:2) {
  for (j in 1:3) {
    ds <- density.ppp(ppp_locations, sigma = sigma[j], kernel = kernels[i])
    plot(ds,
      main = paste0(main[i], ", sigma: ", sigma[j])
    )
    plot(ppp_locations, add = TRUE, cex = 0.01, regular = FALSE)
  }
}
```

## Estimación paramétrica{.tabset}

### Modelo Base
```{r}
base_loc <- ppm(ppp_locations ~1)
base_loc
```


### Modelo Log-linear
```{r}
loglin_loc <- ppm(ppp_locations ~ x + y)
coef(loglin_loc)
```

### Modelo Log-Cuadratico 

```{r}
logquad_loc <- ppm(ppp_locations ~ polynom(x, y, 2))
coef(logquad_loc)

```

### Gráficas modelos 

```{r}
par(mar = c(0, 0, 1.5, 1.5),
    mfrow = c(1, 2),
    cex.main = 2)

plot(predict(loglin_loc), main = "log-linear")
points(ppp_locations, pch = 16, cex = 0.2)

plot(predict(logquad_loc), main = "log-quadratic")
points(ppp_locations, pch = 16, cex = 0.2)
```

## Evaluación de modelos

Una vez que hemos ajustado el modelo log-quadrático a nuestros datos, es fundamental evaluar su adecuación mediante el análisis de los residuales. Las curvas suavizadas en el gráfico de diagnóstico nos muestran cómo se ajusta el modelo a las ubicaciones, revelando patrones significativos en la distribución de los datos.

```{r}
par(mar = c(0, 0, 1.5, 1.5),
    mfrow = c(1, 2),
    cex.main = 1.5)

diagnose.ppm(loglin_loc, which = "smooth", main = "loglin model")
diagnose.ppm(logquad_loc, which = "smooth", main = "Log-quatratic model")
```

# Tipo de estructura{.tabset}

## Distancia de espacio vacío

Debido a que $\hat{F}(r)< F_{pois} (r)$  para las tres estimaciones corregidas, sugiere un patrón agrupado.

```{r}
plot(Fest(ppp_locations), main = "Función F")
```



## Distancia del vecino más cercano

Las ubicaciones observadas están más cerca entre ellas de lo esperado para un patrón agrupado. Todas las estimaciones $\hat{G}(r)> G_{pois} (r)$, sugiere un patrón agrupado.

```{r}
plot(Gest(ppp_locations), main = "Función G" )
```

## La función J 

$J(r) < 1 $ lo que sugiere un patrón agrupado.

```{r}
plot(Jest(ppp_locations), main = "Función J")

```

# Test de Monte Carlo 

```{r}
M <- 39
k <- 1
```
```{r, message=TRUE,include=FALSE}
FE <- envelope(ppp_locations, Fest, M, 1)
GE <- envelope(ppp_locations, Gest, M, 1)
JE <- envelope(ppp_locations, Jest, M, 1)
```


```{r}
par(mfrow = c(1,3), mar = c(0, 0, 1, 1))
plot(FE, main = "Function F Envelopes")
plot(GE, main = "Function G Envelopes")
plot(JE, main = "Function J Envelopes")
```


